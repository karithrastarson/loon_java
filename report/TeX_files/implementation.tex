The programming language of choice for this project was JAVA. That was well suitable for an object oriented problem such as this. Eclipse was used as an IDE not only because of familiarity, but also due to all the handy refactoring tools that come built in to the environment. This is helpful when the code starts to look complicated, to be easily able to extract lines of code and store it within a private helper function. The toolkits SWING and AWT were used for the development of the GUI.

The project was stored on GitHub\footnote{www.github.com/karithrastarson} and is accessible to everyone. The process was iterative where a running version of the model was ready early, and then built upon for the duration of the period.
\subsection{Balloon}

The balloon class is an expert for the balloon. The following attributes are used to describe the object:
\begin{description}
	\item[int x]: X coordinates in the plane
	\item[int y]: Y coordinates in the plane
	\item[int altitude]: the altitude is used to determine wind layer
		\item[int age]: the number of steps this balloon object has taken.
	\item[boolean isMovingUp]: Used to determine whether this balloon is currently moving up.
	\item[boolean isMovingDown]:Used to determine whether this balloon is currently moving down.
	\item[WindLayer windLayer]: The current wind layer this balloon is located in.
	\item[WindLayer nextLayer]: Used to determine whether where this balloon is headed.
\end{description}

The balloon's main function and responsibility to the model is to move with the wind. This is done with the public function moveWithWind(). The balloon retrieves a wind vector from its current wind layer and adds the x and y components of that vector to its own current location in the grid. The new coordinates are then adjusted by the model, according to the border behaviour as described earlier. The adjustment is made as follows:

\begin{algorithm}[H]
\If{new x $\geq $ WORLD\_SIZE}{set x = x-WORLD\_SIZE}
\If{new x < 0}{set x = x+WORLD\_SIZE}

repeat for Y.\\
\end{algorithm}

The rest of the functions in the Balloon class are classic getters and setters, as well as a toString() and equals() functions.

\subsection{WindLayer}
The WindLayer class is an expert of weather data. Its main attribute is a grid of size equal to the WORLD\_SIZE global variable. The default constructor of the class takes two variables; an ID and the size of the world in which it will be. From that information the constructor takes care of generating mock data for the wind layer.

Two global variables are used to adjust the mock data:
\begin{itemize}
    \item DEFAULT\_SPEED = 45
    \item NOISE = 5
\end{itemize}

Algorithm \ref{alg:mockdata} displays how the mock data is generated. This model uses 4 layers and the constructor uses the ID to determine the general direction. The default speed variable is set to one of the four corners of the plane, based on the ID. Then a random number is generated on the scale from zero to the predefined max noise. Then a random boolean variable determines whether that random number should be added or subtracted from the x direction of the wind vector. Same routine is performed for the y direction. 

\begin{algorithm}[H]

\For {i from 0 to WORLD\_SIZE}{ 
    \For{j from 0 to WORLD\_SIZE}{


\If{Id=0}{x=DEFAULT\_SPEED and y=DEFAULT\_SPEED}


\If{Id=1}{x=DEFAULT\_SPEED and y=-DEFAULT\_SPEED}


\If{Id=2}{x=-DEFAULT\_SPEED and y=DEFAULT\_SPEED}


\If{Id=3}{-DEFAULT\_SPEED and y=-DEFAULT\_SPEED}

div = random number from 0 to NOISE

signX = random boolean

\If{signX}{x + div}
\Else{x - div}\endIf

div = random number from 0 to NOISE

signY = random boolean

\If{signY}{y + div}
\Else{y - div}\endIf

wind[i][j] = wind vector(x,y)
}
\EndFor}
\EndFor
\caption{Pseudocode for generating mock data}
\label{alg:mockdata}
\end{algorithm}


\subsection{Pair}
This class was created when a short survey on the Internet showed that JAVA was not equipped with a convenient generic container class that would store pairs, or tuples. It was easier to implement one from scratch. This class is really simple: it carries two variables of generic types T and R. Then the class is equipped with getters and setters. 

This class was created to contain the wind vectors. Each wind layer has a grid of Pairs. So a pair at coordinates x and y in a grid in the layer tells the wind speed and direction at that particular point.

\subsection{ObjectGrid}
No Java library had a suitable container for this project. The object that this project demanded was a two dimensional grid of a fixed size that could store zero or more objects in each cell. A generic class was implemented, but it was then utilized with Balloon objects in this particular project. This makes it easier to access a particular balloon object based on its coordinates.

The main container of the class looks complex but is in fact really simple. The class has the following attributes:

\begin{lstlisting}
    private ArrayList<ArrayList<ArrayList<F>>> grid;
    private int size;
\end{lstlisting}

The outer two array lists are initialized in the constructor, and a grid of empty array lists created. This grid has the dimensions size x size. Each cell in the grid holds an array list of a generic type that can be populated and modified easily. To find the number of balloons occupying a certain spot, the size of the array list at the corresponding cell in the grid is generated and returned.

\subsection{World}
The world is the controller of the model and contains all the balloons, wind layers and the control algorithms. The class contains a lot of attributes who's sole purpose is debugging and printing to to create graphs. Those attributes will be left out of this documentation. 

The World class has the attributes listed in section \ref{theModel_snp}. The class has two main containers that make up the model:

\begin{lstlisting}
	private ArrayList<WindLayer> stratosphere;
	private ArrayList<Balloon> balloons;

\end{lstlisting}

In addition, the class has three containers that support the decision making and the statistical overview of the simulation:
\begin{lstlisting}
	private ObjectGrid<Balloon> balloons_grid;
	private boolean[][] coverage;
	\end{lstlisting}
The ArrayList called \textit{stratosphere} holds all wind layers of the model in an order. The ArrayList called \textit{balloons} is a collection of all balloons created by the model. The boolean grid called coverage is updated in every step of the simulation with boolean values; true for covered and false for not covered. The ObjectGrid called balloons\_grid keeps track of the position of all balloons in the system.


\begin{algorithm}[H]
    Clear the grid.\\
    \ForAll{Balloon b in balloons}
    {center = Pair(b.getX(), b.getY())\\
        \For{int i = b.getX() - RANGE; i $<$ b.getX() + RANGE; i++}{
        \For{int j = b.getY() - RANGE; j $<$ b.getY() + RANGE; j++}{
        point = Pair(i,j)\\
        
        coverage[i][j] = inCircle(center, point)
        }
        }
    }
 \caption{Update Coverage}
 \label{alg:updateCoverage}
\end{algorithm}

The World class has a private function called updateCoverage() which is in charge of updating the boolean grid. This is described with algorithm \ref{alg:updateCoverage}. This function iterates through all the balloon in the system and inspects a rectangular area around the center of the balloon. This rectangle is visualized in figure \ref{fig:gridAssupmtions}. Each point in this area is passed through a function called inCircle, which applies the mathematical function for a circle to determine whether the point is within the coverage range or not. Either this points is within range or not. The sum of of all connected points is calculated and compared against the sum of the previous step. The difference in covered cells is interpreted as a dropped connection. If the connected cells er fewer than they were in the round before, that means that somebody has lost his Internet connection.

\begin{align}
    \left(x - a \right)^2 + \left( y - b \right)^2=r^2.\notag
\end{align}
where
\begin{align}\notag
     		x &= \text{x-coordinate}\\\notag
				y &= \text{y-coordinate}\\\notag
				a &= \text{x-coordinate of the center point}\\\notag
				b &= \text{y-coordinate of the center point}\\\notag
				r &= \text{radius (Range)}\notag
\end{align}


The constructor is short and only initializes the containers mentioned above without populating them. Then a more elaborate initialization function (called init(char c)) can be called with a character as an input, indicating which algorithm to use for the simulation. The \textit{init} function creates four wind layers and adds them to the stratosphere. Furthermore it outputs the windlayers to text files so they can be plotted and analyzed. The outcome is displayed in figure \ref{fig:windLayers}. 

One by one the balloons are created at placed at point (0,0) in the grid. Each step of the simulation adds on balloon and moves the rest. This will prevent the cell (0,0) from clogging on the first step.
The simluation is a repetition of the private function \textit{step()} and repeated as many times as the parameter of the model says. Each step is an execution of the following:

\begin{algorithm}[H]
\If{No. of balloons in system $<$ NUMBER\_OF\_BALLOONS}{createBalloon()}

\ForAll{balloons in system}{
applyDecision()
moveBalloon()
}

\ForAll{balloons in system}{
\If{Age of balloon $\geq$ LIFETIME}{removeBalloon()}
}

updateStatistics()
\end{algorithm}

The applyDecision() function is the actual control algorithm to which another section of this paper is dedicated. The moveBalloon() function is the thoughtful procedure of moving the balloon in the model and updating the appropriate containers. First the altitude is adjusted according to the vertical speed if the balloon is marked as moving up or down. Then a check is performed to see if the change in altitude affected the wind layer in which the balloon is. This is done with a function called \textit{getLayerFromAltitude} where each wind layer is assigned a certain space between the global variables that indicate the maximum and minimum altitude. The \textit{windLayer} attribute of the balloon is then updated and compared to the \textit{nextLayer} attribute to see if the vertical movement of the balloon should be stopped or not. 

When the balloon has been placed in the correct wind layer it can be moved around in the grid of balloons with the corresponding wind vector. The previous location as well as the new location of the balloons are updated in the grid to represent the actual movement. 